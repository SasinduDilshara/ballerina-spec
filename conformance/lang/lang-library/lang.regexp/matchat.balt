Test-Case: output
Description: Test `matchAt` function.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function init() {
    var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string:RegExp phoneRegex = re `^\+?[0-9]{10,14}$`;
    string str1 = "abc@gmail.com";
    string str2 = "abcd1AB<> C\\d";
    string str3 = "+94111111111";

    regexp:Span? res1 = emailRegex.matchAt("NotMatching");
    io:println(res1 is ()); // @output true

    regexp:Span? res2 = emailRegex.matchAt(str1);
    io:println(res2 is regexp:Span); // @output true
    regexp:Span res2span = <regexp:Span> res2;
    io:println(res2span.startIndex); // @output 0
    io:println(res2span.endIndex);  // @output 13

    regexp:Span? res3 = regexp:matchAt(re `\d\D*\w\W\W\s\S\\d`, str2, 4);
    io:println(res3 is regexp:Span); // @output true
    regexp:Span res3span = <regexp:Span> res3;
    io:println(res3span.startIndex); // @output 4
    io:println(res3span.endIndex); // @output 13

    regexp:Span res4span = <regexp:Span> phoneRegex.matchAt(str3, 0);
    io:println(res4span.startIndex); // @output 0
    io:println(res4span.endIndex); // @output 12

    regexp:Span? res5 = re `(?im-sx:H*ere?!?)`.matchAt("matchhere", 4);
    io:println(res5 is regexp:Span); // @output true
    regexp:Span res5span = <regexp:Span> res5;
    io:println(res5span.startIndex); // @output 4
    io:println(res5span.endIndex); // @output 9

    regexp:Span? res6 = re `${"3*"}`.matchAt("2333", 2);
    io:println(res6 is regexp:Span); // @output true
    regexp:Span res6span = <regexp:Span> res6;
    io:println(res6span.startIndex); // @output 2
    io:println(res6span.endIndex); // @output 4

    regexp:Span? res7 = re `${""}`.matchAt("empty match");
    io:println(res7 is regexp:Span); // @output false

    regexp:Span? res8 = regexp:matchAt(re = re `\p{sc=Greek}\P{Lu}`, str = "ThisisGreekCharacterWithNumberΑ1", startIndex = 30);
    io:println(res8 is regexp:Span); // @output true
    regexp:Span res8span = <regexp:Span> res8;
    io:println(res8span.startIndex); // @output 30
    io:println(res8span.endIndex); // @output 32

    regexp:Span? res9 = re `cde.*123`.matchAt("abcdefgh123", 2);
    io:println(res9 is regexp:Span); // @output true
    regexp:Span res9span = <regexp:Span> res9;
    io:println(res9span.startIndex); // @output 2
    io:println(res9span.endIndex);  // @output 11
}

Test-Case: output
Description: Test `matchAt` function at module level.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
string:RegExp phoneRegex = re `^\+?[0-9]{10,14}$`;
string str1 = "abc@gmail.com";
string str2 = "abcd1AB<> C\\d";
string str3 = "+94111111111";

regexp:Span? res1 = emailRegex.matchAt("NotMatching");
regexp:Span? res2 = emailRegex.matchAt(str1);
regexp:Span? res3 = regexp:matchAt(re `\d\D*\w\W\W\s\S\\d`, str2, 4);
regexp:Span res4span = <regexp:Span> phoneRegex.matchAt(str3, 0);
regexp:Span? res5 = re `(?im-sx:H*ere?!?)`.matchAt("matchhere", 4);
regexp:Span? res6 = re `${"3*"}`.matchAt("2333", 2);
regexp:Span? res7 = re `${""}`.matchAt("empty match");
regexp:Span? res8 = regexp:matchAt(re = re `\p{sc=Greek}\P{Lu}`, str = "ThisisGreekCharacterWithNumberΑ1", startIndex = 30);
regexp:Span? res9 = re `cde.*123`.matchAt("abcdefgh123", 2);

function init() {
    io:println(res1 is ()); // @output true

    io:println(res2 is regexp:Span); // @output true
    regexp:Span res2span = <regexp:Span> res2;
    io:println(res2span.startIndex); // @output 0
    io:println(res2span.endIndex);  // @output 13

    io:println(res3 is regexp:Span); // @output true
    regexp:Span res3span = <regexp:Span> res3;
    io:println(res3span.startIndex); // @output 4
    io:println(res3span.endIndex); // @output 13

    io:println(res4span.startIndex); // @output 0
    io:println(res4span.endIndex); // @output 12

    io:println(res5 is regexp:Span); // @output true
    regexp:Span res5span = <regexp:Span> res5;
    io:println(res5span.startIndex); // @output 4
    io:println(res5span.endIndex); // @output 9

    io:println(res6 is regexp:Span); // @output true
    regexp:Span res6span = <regexp:Span> res6;
    io:println(res6span.startIndex); // @output 2
    io:println(res6span.endIndex); // @output 4

    io:println(res7 is regexp:Span); // @output false

    io:println(res8 is regexp:Span); // @output true
    regexp:Span res8span = <regexp:Span> res8;
    io:println(res8span.startIndex); // @output 30
    io:println(res8span.endIndex); // @output 32

    io:println(res9 is regexp:Span); // @output true
    regexp:Span res9span = <regexp:Span> res9;
    io:println(res9span.startIndex); // @output 2
    io:println(res9span.endIndex);  // @output 11
}

Test-Case: output
Description: Test `matchAt` function with negative range.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function init() {
    var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string str1 = "abc@gmail.com";
    regexp:Span|error? err =  trap emailRegex.matchAt(str1, -5);
    io:println(err is error); // @output true
    io:println((<error> err).detail().get("message").ensureType()); // @output start index cannot be less than 0
}

Test-Case: error
Description: Test `matchAt` function with large integer values.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string str1 = "abc@gmail.com";

    regexp:Span? _ = emailRegex.matchAt(str1, 1000000000000000000000); // @error out of range
}

Test-Case: output
Description: Test assignability of `matchAt` function result.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function init() {
    var emailRegex = re `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string str1 = "bcd";

    any result1 = emailRegex.matchAt("acd@gmail.com");
    io:println(result1 is regexp:Span); // @output true

    var result2 = re `cd`.matchAt(str1, 1);
    io:println(result2 is regexp:Span); // @output true

    var result3 = regexp:matchAt(re = emailRegex, str = str1, startIndex = 2);
    io:println(result3 is ()); // @output true
}

Test-Case: error
Description: Test assigning the result of `matchAt` function to an incompatible type.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var phoneRegex = re `^\+?[0-9]{10,14}$`;
    string str1 = "+94111111111";

    regexp:Span _ = phoneRegex.matchAt(str1, 5); // @error expects a regexp:Span, but matchAt() returns regexp:Span?
    int _ = re `.*`.matchAt(str = str1); // @error expects a int, but matchAt() returns regexp:Span?
    string _ = regexp:matchAt(re = phoneRegex, str = str1, startIndex = 5); // @error expects a string, but matchAt() returns regexp:Span?
}


Test-Case: error
Description: Test missing required parameters for `matchAt` method.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string str1 = "abcde@gmail.com";

    regexp:Span? _ = emailRegex.matchAt(); // @error missing string argument
    regexp:Span? _ = regexp:matchAt(emailRegex); // @error missing string argument
    regexp:Span? _ = regexp:matchAt(str = ""); // @error missing required parameter 're' in call to 'matchAt()'
    regexp:Span? _ = re `abc`.matchAt(); // @error missing string argument
}

Test-Case: error
Description: Test passing invalid parameters to `matchAt()` method.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function errorFunction(string|int si) {
    var emailRegex = re `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
    string str1 = "abcde@gmail.com";

    regexp:Span? _ = emailRegex.matchAt(12); // @error expected 'string', found 'int'
    regexp:Span? _ = emailRegex.matchAt("MatchHereAndHere", "5"); // @error expected 'int', found 'string'
    regexp:Span? _ = regexp:matchAt(re = "abc", str = "MatchHereAndHere",  startIndex = 2); // @error expected 'regexp:RegExp', found 'string'
}

Test-Case: error
Description: Test passing too many parameters to `matchAt()` method.
Labels: function-call-expr, regexp, matchAt, method-call-expr

import ballerina/lang.regexp;

function errorFunction(string|int si) {
    var regExpr1 = re `Here`;

    regexp:Span? _ = regExpr1.matchAt("MatchHere", 5, 1); // @error too many arguments
}
