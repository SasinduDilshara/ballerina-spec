Test-Case: output
Description: Test `fromString` function with regexp result.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function init() {
    string emailRegex = string `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;

    string:RegExp|error x = regexp:fromString("A\\p{Lu}??B+\\W\\(+?C*D{1,4}?");
    io:println(x is string:RegExp); // @output true
    io:println(x is string:RegExp && re `A\p{Lu}??B+\W\(+?C*D{1,4}?` == x); // @output true

    var x2 = regexp:fromString(emailRegex);
    io:println(x2 is string:RegExp); // @output true
    io:println(x2 is string:RegExp && re `${emailRegex}` == x2); // @output true
}

Test-Case: output
Description: Test `fromString` function at module level.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

string emailRegex = string `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`;
string:RegExp|error x = regexp:fromString("A\\p{Lu}??B+\\W\\(+?C*D{1,4}?");
var x2 = regexp:fromString(emailRegex);

function init() {
    io:println(x is string:RegExp); // @output true
    io:println(x is string:RegExp && re `A\p{Lu}??B+\W\(+?C*D{1,4}?` == x); // @output true

    io:println(x2 is string:RegExp); // @output true
    io:println(x2 is string:RegExp && re `${emailRegex}` == x2); // @output true
}

Test-Case: output
Description: Test `fromString` function with error result.
Labels: function-call-expr, regexp, regexp:fromString, string, error

import ballerina/lang.regexp;

function init() {
    string errorRegex = "AB+^*";

    string:RegExp|error x = regexp:fromString("AB+^*");
    io:println(x is error); // @output true

    string:RegExp|error x2 = regexp:fromString("(abc");
    io:println(x2 is error); // @output true

    string:RegExp|error x3 = regexp:fromString(errorRegex);
    io:println(x3 is error); // @output true
}

Test-Case: output
Description: Test assignability of `regexp:fromString` function result.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function init() {
    any|error result1 = regexp:fromString("regexp");
    io:println(result1 is string:RegExp); // @output true
    io:println(re `regexp` == result1); // @output true

    var result2 = regexp:fromString("regexp");
    io:println(result2 is string:RegExp); // @output true
    io:println(re `regexp` == result2); // @output true

    var result3 = regexp:fromString("[[]]]]");
    io:println(result3 is error); // @output true
}

Test-Case: error
Description: Test assigning the result of `regexp:fromString` function to an incompatible type.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function errorFunction() {
    int _ = regexp:fromString("regexp"); // @error expected 'int', found '(regexp:RegExp|error)'
    string:Char _ = regexp:fromString("regexp"); // @error expected 'string:Char', found '(regexp:RegExp|error)'
}


Test-Case: error
Description: Test missing required parameters for `regexp:fromString` method.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function errorFunction() {
    string:RegExp _ = regexp:fromString(); // @error missing string argument
}

Test-Case: error
Description: Test passing invalid parameters to `regexp:fromString` method.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function errorFunction() {
    string:RegExp|error e = regexp:fromString(1213); // @error expected 'string', found 'int'
}

Test-Case: error
Description: Test passing too many parameters to `regexp:fromString` method.
Labels: function-call-expr, regexp, regexp:fromString, string

import ballerina/lang.regexp;

function errorFunction() {
    string:RegExp _ = regexp:fromString("this", "that"); // @error too many arguments
}
